@namespace BlazorBlueprint.Primitives.Floating
@using BlazorBlueprint.Primitives.Services
@using Microsoft.Extensions.Logging
@inject IPositioningService PositioningService
@inject IPortalService PortalService
@inject IJSRuntime JSRuntime
@inject ILogger<BbFloatingPortal> Logger
@implements IAsyncDisposable

@*
    FloatingPortal - Unified infrastructure for floating content.
    Handles ONLY: portal registration, positioning, and lifecycle management.
    Does NOT handle: click-outside, keyboard navigation, or any behavior.

    When ForceMount is true (default), portal content stays registered in the DOM
    when closed — hidden via CSS instead of unmounted. This eliminates re-mount
    overhead and enables CSS exit animations via the data-state attribute.

    Use this as the base layer for Select, Popover, DropdownMenu, Tooltip, etc.
*@

@code {
    /// <summary>
    /// The content to render in the floating portal.
    /// </summary>
    [Parameter]
    public RenderFragment? ChildContent { get; set; }

    /// <summary>
    /// Whether the floating content is currently visible.
    /// </summary>
    [Parameter]
    public bool IsOpen { get; set; }

    /// <summary>
    /// Whether to keep portal content mounted in the DOM when closed.
    /// When true, content is hidden via CSS instead of being unmounted, eliminating
    /// re-mount overhead on each open/close cycle. A <c>data-state</c> attribute
    /// (<c>"open"</c> / <c>"closed"</c>) on the content div enables CSS animations.
    /// Default is true.
    /// </summary>
    [Parameter]
    public bool ForceMount { get; set; } = true;

    /// <summary>
    /// The element to position the floating content relative to.
    /// </summary>
    [Parameter]
    public ElementReference? AnchorElement { get; set; }

    /// <summary>
    /// Unique identifier for this portal instance.
    /// Required to prevent conflicts when multiple floating elements exist.
    /// </summary>
    [Parameter]
    public string PortalId { get; set; } = "";

    /// <summary>
    /// Preferred side for positioning.
    /// Default is Bottom.
    /// </summary>
    [Parameter]
    public PopoverSide Side { get; set; } = PopoverSide.Bottom;

    /// <summary>
    /// Alignment relative to anchor element.
    /// Default is Center.
    /// </summary>
    [Parameter]
    public PopoverAlign Align { get; set; } = PopoverAlign.Center;

    /// <summary>
    /// Offset distance from the anchor element in pixels.
    /// Default is 4.
    /// </summary>
    [Parameter]
    public int Offset { get; set; } = 4;

    /// <summary>
    /// Whether to match the floating content width to the anchor element width.
    /// Default is false.
    /// </summary>
    [Parameter]
    public bool MatchAnchorWidth { get; set; } = false;

    /// <summary>
    /// CSS positioning strategy.
    /// Use <see cref="PositioningStrategy.Fixed"/> for dropdowns that need to escape stacking contexts.
    /// Default is <see cref="PositioningStrategy.Absolute"/>.
    /// </summary>
    [Parameter]
    public PositioningStrategy Strategy { get; set; } = PositioningStrategy.Absolute;

    /// <summary>
    /// CSS z-index value for the floating content.
    /// Default is 50.
    /// </summary>
    [Parameter]
    public int ZIndex { get; set; } = 50;

    /// <summary>
    /// Event callback invoked when the floating content is positioned and visible.
    /// Use this to set up keyboard navigation, focus management, etc.
    /// Fires on every open, including re-opens when ForceMount is true.
    /// </summary>
    [Parameter]
    public EventCallback OnReady { get; set; }

    /// <summary>
    /// Additional attributes to apply to the portal container.
    /// </summary>
    [Parameter(CaptureUnmatchedValues = true)]
    public Dictionary<string, object>? AdditionalAttributes { get; set; }

    private static readonly Action<ILogger, string, Exception?> LogPortalRenderTimeout =
        LoggerMessage.Define<string>(LogLevel.Warning, new EventId(2, "PortalRenderTimeout"),
            "Portal '{PortalId}' timed out waiting for PortalHost to render. " +
            "Ensure <BbPortalHost /> is in your layout.");

    private static readonly Action<ILogger, string, string, Exception?> LogSetupFailed =
        LoggerMessage.Define<string, string>(LogLevel.Warning, new EventId(3, "FloatingPortalSetupFailed"),
            "FloatingPortal '{PortalId}' setup failed: {ErrorMessage}");

    private static readonly Action<ILogger, string, Exception?> LogPositioningFailed =
        LoggerMessage.Define<string>(LogLevel.Warning, new EventId(4, "PositioningFailed"),
            "Failed to set up positioning for portal '{PortalId}'.");

    private IAsyncDisposable? _positioningCleanup;
    private bool _isMounted = false;
    private bool _isPositioned = false;
    private ElementReference _portalContentRef;
    private TaskCompletionSource<bool>? _portalReadyTcs;

    // Store computed position so it survives Blazor re-renders
    private double _positionLeft = 0;
    private double _positionTop = 0;

    protected override void OnInitialized()
    {
        if (string.IsNullOrEmpty(PortalId))
        {
            throw new InvalidOperationException(
                "FloatingPortal requires a PortalId to be specified. " +
                "Each floating element must have a unique identifier.");
        }

        // Subscribe to portal ready events for synchronization
        PortalService.OnPortalRendered += HandlePortalRendered;
    }

    private void HandlePortalRendered(string portalId)
    {
        if (portalId == PortalId)
        {
            _portalReadyTcs?.TrySetResult(true);
        }
    }

    protected override void OnParametersSet()
    {
        base.OnParametersSet();
        // When the portal is mounted, notify PortalHost to re-render so that content
        // updates (e.g., data-state changes, child content updates) are reflected.
        // Uses RefreshPortal (not RegisterPortal) to avoid replacing the RenderFragment
        // delegate, which would break ElementReference stability. The existing delegate
        // captures 'this', so PortalHost reads current ChildContent automatically.
        // Note: PortalHost ignores refresh calls during its own render cycle, preventing
        // infinite loops when FloatingPortal is nested inside another portal.
        if (_isMounted && !string.IsNullOrEmpty(PortalId))
        {
            PortalService.RefreshPortal(PortalId);
        }
    }

    protected override async Task OnAfterRenderAsync(bool firstRender)
    {
        if (ForceMount)
        {
            await HandleForceMountLifecycleAsync();
        }
        else
        {
            await HandleStandardLifecycleAsync();
        }
    }

    /// <summary>
    /// ForceMount lifecycle: portal stays registered across open/close.
    /// Content is hidden via CSS when closed, positioned when open.
    /// </summary>
    private async Task HandleForceMountLifecycleAsync()
    {
        if (!_isMounted)
        {
            // First mount: register portal immediately (regardless of IsOpen)
            await MountPortalAsync();

            // If already open on mount, set up positioning
            if (IsOpen)
            {
                await SetupAsync();
            }
        }
        else if (IsOpen && !_isPositioned)
        {
            // Open transition: portal is already mounted, just need to position
            // Yield to ensure Blazor re-render completes and _portalContentRef is valid
            await Task.Yield();

            // Check if still open (user might have closed during yield)
            if (!IsOpen)
            {
                return;
            }

            await SetupAsync();
        }
        else if (!IsOpen && _isPositioned)
        {
            // Close transition: hide content but keep portal registered
            await HideAsync();
        }
    }

    /// <summary>
    /// Standard lifecycle (ForceMount=false): mount on open, unmount on close.
    /// This is the original behavior for backwards compatibility.
    /// </summary>
    private async Task HandleStandardLifecycleAsync()
    {
        if (IsOpen && !_isMounted)
        {
            await MountPortalAsync();

            // Check if still open (user might have closed during wait)
            if (!IsOpen)
            {
                return;
            }

            await SetupAsync();
        }
        else if (!IsOpen && _isMounted)
        {
            await CleanupAsync();
        }
    }

    /// <summary>
    /// Registers the portal with PortalService and waits for PortalHost to render it.
    /// </summary>
    private async Task MountPortalAsync()
    {
        _isMounted = true;
        _isPositioned = false;

        // Create completion source BEFORE registering portal
        _portalReadyTcs = new TaskCompletionSource<bool>();

        // Register content through portal - this triggers PortalHost to re-render
        PortalService.RegisterPortal(PortalId, RenderPortalContent(), PortalCategory.Overlay);

        // Wait for PortalHost to signal it's done rendering our portal
        // Use timeout to prevent hanging if something goes wrong
        var timeoutTask = Task.Delay(500);
        var completedTask = await Task.WhenAny(_portalReadyTcs.Task, timeoutTask);

        if (completedTask == timeoutTask)
        {
            LogPortalRenderTimeout(Logger, PortalId, null);
        }

        // Yield to ensure any pending re-renders complete and _portalContentRef is up-to-date
        // This is critical when multiple portals are opening/closing simultaneously
        await Task.Yield();
    }

    /// <summary>
    /// Sets up positioning after portal has rendered.
    /// </summary>
    private async Task SetupAsync()
    {
        try
        {
            // Set up positioning and make visible via JS
            await SetupPositioningAsync();

            // Mark as positioned for any future Blazor re-renders
            _isPositioned = true;

            // Notify consumers that content is ready (for focus management, keyboard handlers, etc.)
            if (OnReady.HasDelegate)
            {
                await OnReady.InvokeAsync();
            }
        }
        catch (Exception ex)
        {
            LogSetupFailed(Logger, PortalId, ex.Message, ex);
            // Mark as positioned and show via JS even if setup fails
            _isPositioned = true;
            try
            {
                var elementUtilsModule = await JSRuntime.InvokeAsync<IJSObjectReference>(
                    "import", "./_content/BlazorBlueprint.Primitives/js/primitives/element-utils.js");
                await elementUtilsModule.InvokeVoidAsync("showElement", PortalId);
                await elementUtilsModule.DisposeAsync();
            }
            catch { /* ignore */ }
        }
    }

    private RenderFragment RenderPortalContent() => __builder =>
    {
        <div @ref="_portalContentRef"
             @attributes="GetAttributesWithoutStyle()"
             data-portal-content="true"
             data-state="@(IsOpen ? "open" : "closed")"
             style="@GetMergedStyle()">
            @ChildContent
        </div>
    };

    private async Task SetupPositioningAsync()
    {
        if (AnchorElement == null || !AnchorElement.HasValue)
        {
            Logger.LogWarning("FloatingPortal '{PortalId}' - AnchorElement is null, positioning may not work correctly", PortalId);
            return;
        }

        try
        {
            // Construct placement string from Side and Align
            var placement = Align == PopoverAlign.Center ? Side.ToValue() : $"{Side.ToValue()}-{Align.ToValue()}";

            var options = new PositioningOptions
            {
                Placement = placement,
                Offset = Offset,
                MatchReferenceWidth = MatchAnchorWidth,
                Strategy = Strategy,
                Flip = true,  // Enable flip to opposite side when not enough space
                Shift = true  // Enable shift to keep in viewport
            };

            // Compute position using the portal content ref
            var position = await PositioningService.ComputePositionAsync(
                AnchorElement.Value,
                _portalContentRef,
                options);

            // Store position in Blazor state so it survives re-renders
            _positionLeft = position.X;
            _positionTop = position.Y;

            // Apply position via JS for initial display
            await PositioningService.ApplyPositionAsync(_portalContentRef, position, makeVisible: true);

            // Set up auto-update for dynamic positioning (scroll, resize)
            _positioningCleanup = await PositioningService.AutoUpdateAsync(
                AnchorElement.Value,
                _portalContentRef,
                options);
        }
        catch (Exception ex)
        {
            LogPositioningFailed(Logger, PortalId, ex);
        }
    }

    /// <summary>
    /// Gets the initial inline style for the portal content.
    /// </summary>
    private string GetInitialStyle()
    {
        if (!_isPositioned || !IsOpen)
        {
            // Use position: fixed with off-screen coordinates to prevent:
            // 1. Flash at wrong position (fixed doesn't depend on parent context)
            // 2. Scroll jump (visibility: hidden prevents browser from scrolling to element)
            // 3. Layout interference (pointer-events: none prevents interaction)
            // Also applied when IsOpen is false — ensures content hides immediately on close,
            // without waiting for OnAfterRenderAsync to set _isPositioned = false.
            return $"position: fixed; z-index: {ZIndex}; top: -9999px; left: -9999px; visibility: hidden; opacity: 0; pointer-events: none;";
        }

        // After positioning, include stored position so it survives Blazor re-renders
        // This prevents the content from "closing" when parent components re-render
        return $"position: {Strategy.ToValue()}; z-index: {ZIndex}; left: {_positionLeft}px; top: {_positionTop}px; opacity: 1; visibility: visible;";
    }

    private string GetMergedStyle()
    {
        var baseStyle = GetInitialStyle();

        if (AdditionalAttributes != null && AdditionalAttributes.TryGetValue("style", out var userStyle))
        {
            return $"{userStyle}; {baseStyle}";
        }

        return baseStyle;
    }

    private Dictionary<string, object>? GetAttributesWithoutStyle()
    {
        if (AdditionalAttributes == null)
        {
            return null;
        }

        var attributes = new Dictionary<string, object>(AdditionalAttributes);
        attributes.Remove("style");

        return attributes.Count > 0 ? attributes : null;
    }

    /// <summary>
    /// Hides the floating content by disposing positioning, without unregistering the portal.
    /// Used by ForceMount on close — content stays in DOM but hidden.
    /// </summary>
    private async Task HideAsync()
    {
        // Dispose positioning auto-update
        if (_positioningCleanup != null)
        {
            await _positioningCleanup.DisposeAsync();
            _positioningCleanup = null;
        }

        _isPositioned = false;
    }

    /// <summary>
    /// Fully cleans up: hides content AND unregisters the portal from PortalService.
    /// Used by standard lifecycle (ForceMount=false) and on component disposal.
    /// </summary>
    private async Task CleanupAsync()
    {
        await HideAsync();

        // Unregister portal when content closes or component disposes
        if (!string.IsNullOrEmpty(PortalId))
        {
            PortalService.UnregisterPortal(PortalId);
        }

        _isMounted = false;
    }

    public async ValueTask DisposeAsync()
    {
        // Unsubscribe from portal ready events
        PortalService.OnPortalRendered -= HandlePortalRendered;

        await CleanupAsync();
    }
}
