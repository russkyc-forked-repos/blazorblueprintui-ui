@namespace BlazorBlueprint.Primitives.Popover
@using BlazorBlueprint.Primitives.Utilities

@* Popover trigger - opens the popover when clicked *@
@if (AsChild)
{
    @* When AsChild is true, pass trigger context to child for it to handle *@
    <CascadingValue Value="GetTriggerContext()" Name="TriggerContext">
        @ChildContent
    </CascadingValue>
}
else
{
    <button type="button"
            id="@Context.TriggerId"
            @ref="@_triggerRef"
            @onclick="HandleClick"
            @attributes="AdditionalAttributes"
            aria-haspopup="true"
            aria-expanded="@Context.IsOpen.ToString().ToLower()"
            aria-controls="@Context.ContentId"
            style="@(Context.IsOpen ? "pointer-events: none;" : "")">
        @ChildContent
    </button>
}

@code {
    [CascadingParameter]
    private PopoverContext Context { get; set; } = null!;

    private ElementReference _triggerRef;

    /// <summary>
    /// The content to display inside the trigger button.
    /// </summary>
    [Parameter]
    public RenderFragment? ChildContent { get; set; }

    /// <summary>
    /// When true, the trigger does not render its own button element.
    /// Instead, it passes trigger behavior via TriggerContext to child components.
    /// The child component must consume TriggerContext and apply click/aria behavior.
    /// </summary>
    [Parameter]
    public bool AsChild { get; set; } = false;

    /// <summary>
    /// Additional attributes to apply to the trigger button element.
    /// </summary>
    [Parameter(CaptureUnmatchedValues = true)]
    public Dictionary<string, object>? AdditionalAttributes { get; set; }

    /// <summary>
    /// Custom click handler. If provided, this is called in addition to the default toggle behavior.
    /// </summary>
    [Parameter]
    public EventCallback<MouseEventArgs> OnClick { get; set; }

    /// <summary>
    /// Whether to use custom click handling. When true, only OnClick is invoked.
    /// Default is false (popover opens on click).
    /// </summary>
    [Parameter]
    public bool CustomClickHandling { get; set; } = false;

    /// <summary>
    /// Stores the trigger element reference when using AsChild pattern.
    /// </summary>
    private ElementReference? _asChildTriggerRef;

    /// <summary>
    /// Cached TriggerContext to avoid unnecessary CascadingValue change propagation.
    /// Only recreated when dependencies (IsOpen, TriggerId, ContentId) actually change.
    /// </summary>
    private TriggerContext? _cachedTriggerContext;
    private bool _cachedIsOpen;
    private string? _cachedTriggerId;
    private string? _cachedContentId;

    private TriggerContext GetTriggerContext()
    {
        if (_cachedTriggerContext == null ||
            _cachedIsOpen != Context.IsOpen ||
            _cachedTriggerId != Context.TriggerId ||
            _cachedContentId != Context.ContentId)
        {
            _cachedIsOpen = Context.IsOpen;
            _cachedTriggerId = Context.TriggerId;
            _cachedContentId = Context.ContentId;
            _cachedTriggerContext = new TriggerContext
            {
                TriggerId = Context.TriggerId,
                IsOpen = Context.IsOpen,
                // Toggle now only opens when closed (to prevent Blazor event routing edge cases)
                Toggle = () => { if (!Context.IsOpen) Context.Open(_asChildTriggerRef); },
                Open = () => Context.Open(_asChildTriggerRef),
                Close = () => Context.Close(),
                AriaHasPopup = "true",
                AriaControls = Context.ContentId,
                SetTriggerElement = (ElementReference el) => _asChildTriggerRef = el
            };
        }
        return _cachedTriggerContext;
    }

    private async Task HandleClick(MouseEventArgs args)
    {
        // IMPORTANT: Only OPEN the popover from the trigger, never close it.
        // Closing is handled by click-outside detection or explicit close actions.
        // This prevents Blazor Server event routing edge cases where clicks inside
        // the popover content can incorrectly trigger the trigger's click handler
        // during component re-renders.
        if (Context.IsOpen)
        {
            return;
        }

        if (CustomClickHandling && OnClick.HasDelegate)
        {
            // Custom handling only
            await OnClick.InvokeAsync(args);
        }
        else
        {
            // Default: open popover and store trigger element for positioning
            Context.Open(_triggerRef);

            // Also invoke custom handler if provided
            if (OnClick.HasDelegate)
            {
                await OnClick.InvokeAsync(args);
            }
        }
    }

    protected override void OnInitialized()
    {
        if (Context == null)
        {
            throw new InvalidOperationException(
                "PopoverTrigger must be used within a Popover component. " +
                "Ensure PopoverTrigger is a child of a Popover component.");
        }
    }

    protected override void OnAfterRender(bool firstRender)
    {
        // Proactively set the trigger element reference so it's available
        // even when the popover is opened programmatically (via @bind-Open)
        // This runs after every render to ensure the reference stays current
        if (!AsChild)
        {
            Context.SetTriggerElement(_triggerRef);
        }
        else if (_asChildTriggerRef.HasValue)
        {
            // When using AsChild pattern, the child component (e.g., Button) sets
            // _asChildTriggerRef via TriggerContext.SetTriggerElement. We need to
            // propagate this to the context so Content can position relative to it.
            Context.SetTriggerElement(_asChildTriggerRef.Value);
        }
    }
}
