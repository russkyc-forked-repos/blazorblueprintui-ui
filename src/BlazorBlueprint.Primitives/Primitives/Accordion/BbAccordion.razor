@namespace BlazorBlueprint.Primitives.Accordion
@implements IAsyncDisposable
@inject IJSRuntime JSRuntime

@* Accordion primitive root component - headless, unstyled behavior only *@
<div @ref="_elementRef" @attributes="AdditionalAttributes">
    <CascadingValue Value="@_context" IsFixed="false">
        <CascadingValue Value="this" IsFixed="true">
            @ChildContent
        </CascadingValue>
    </CascadingValue>
</div>

@code {
    private AccordionContext _context = new();
    private UseControllableState<HashSet<string>> _state = null!;
    private List<BbAccordionTrigger> _triggers = new();
    private ElementReference _elementRef;
    private IJSObjectReference? _keyboardNavModule;
    private IJSObjectReference? _keyboardNavCleanup;
    private bool _disposed;

    /// <summary>
    /// The child content to render within the accordion context.
    /// Should contain AccordionItem components.
    /// </summary>
    [Parameter]
    public RenderFragment? ChildContent { get; set; }

    /// <summary>
    /// Controls which items are open (controlled mode).
    /// When null, the accordion manages its own state (uncontrolled mode).
    /// </summary>
    [Parameter]
    public HashSet<string>? Value { get; set; }

    /// <summary>
    /// Event callback invoked when the open items change.
    /// Use with @bind-Value for two-way binding.
    /// </summary>
    [Parameter]
    public EventCallback<HashSet<string>> ValueChanged { get; set; }

    /// <summary>
    /// Default open items when in uncontrolled mode.
    /// </summary>
    [Parameter]
    public HashSet<string>? DefaultValue { get; set; }

    /// <summary>
    /// Event callback invoked when the open items change.
    /// Receives the new set of open item values as a parameter.
    /// </summary>
    [Parameter]
    public EventCallback<HashSet<string>> OnValueChange { get; set; }

    /// <summary>
    /// Type of accordion (single or multiple).
    /// Default is single.
    /// </summary>
    [Parameter]
    public AccordionType Type { get; set; } = AccordionType.Single;

    /// <summary>
    /// Whether items can be collapsed when in single mode.
    /// Default is false (one item must always be open).
    /// </summary>
    [Parameter]
    public bool Collapsible { get; set; } = false;

    /// <summary>
    /// Additional attributes to apply to the root div element.
    /// </summary>
    [Parameter(CaptureUnmatchedValues = true)]
    public Dictionary<string, object>? AdditionalAttributes { get; set; }

    protected override void OnInitialized()
    {
        // Initialize controllable state
        _state = new UseControllableState<HashSet<string>>(DefaultValue ?? new HashSet<string>())
        {
            ControlledValue = Value ?? new HashSet<string>(),
            OnValueChanged = ValueChanged,
            IsControlled = ValueChanged.HasDelegate
        };

        // Sync initial state to context
        _context.State.OpenValues = new HashSet<string>(_state.Value);
        _context.State.Type = Type;
        _context.State.Collapsible = Collapsible;

        // Subscribe to context state changes
        _context.OnStateChanged += HandleContextStateChanged;
    }

    protected override void OnParametersSet()
    {
        // Update controlled value if it changed
        if (_state.IsControlled && Value != null && _state.ControlledValue != null && !Value.SetEquals(_state.ControlledValue))
        {
            _state.ControlledValue = Value;
            _context.State.OpenValues = new HashSet<string>(Value);
        }

        // Update type and collapsible settings
        _context.State.Type = Type;
        _context.State.Collapsible = Collapsible;
    }

    protected override async Task OnAfterRenderAsync(bool firstRender)
    {
        if (firstRender)
        {
            try
            {
                _keyboardNavModule = await JSRuntime.InvokeAsync<IJSObjectReference>(
                    "import", "./_content/BlazorBlueprint.Primitives/js/primitives/keyboard-nav.js");

                _keyboardNavCleanup = await _keyboardNavModule.InvokeAsync<IJSObjectReference>(
                    "setupKeyboardNav", _elementRef);
            }
            catch (JSDisconnectedException)
            {
                // Circuit disconnected, ignore
            }
        }
    }

    /// <summary>
    /// Registers an accordion trigger for keyboard navigation.
    /// </summary>
    internal void RegisterTrigger(BbAccordionTrigger trigger)
    {
        if (!_triggers.Contains(trigger))
        {
            _triggers.Add(trigger);
        }
    }

    /// <summary>
    /// Unregisters an accordion trigger.
    /// </summary>
    internal void UnregisterTrigger(BbAccordionTrigger trigger)
    {
        _triggers.Remove(trigger);
    }

    /// <summary>
    /// Handles keyboard navigation between accordion triggers.
    /// </summary>
    internal void HandleKeyNavigation(string currentValue, string key)
    {
        if (_triggers.Count == 0) return;

        var currentIndex = _triggers.FindIndex(t => t.Value == currentValue);
        if (currentIndex == -1) return;

        var nextIndex = key switch
        {
            "ArrowDown" => GetNextIndex(currentIndex),
            "ArrowUp" => GetPreviousIndex(currentIndex),
            "Home" => GetFirstEnabledIndex(),
            "End" => GetLastEnabledIndex(),
            _ => -1
        };

        if (nextIndex != -1 && nextIndex != currentIndex)
        {
            _ = _triggers[nextIndex].FocusAsync();
        }
    }

    private int GetNextIndex(int currentIndex)
    {
        for (int i = currentIndex + 1; i < _triggers.Count; i++)
        {
            if (!_triggers[i].Disabled)
            {
                return i;
            }
        }
        // Wrap to first enabled
        return GetFirstEnabledIndex();
    }

    private int GetPreviousIndex(int currentIndex)
    {
        for (int i = currentIndex - 1; i >= 0; i--)
        {
            if (!_triggers[i].Disabled)
            {
                return i;
            }
        }
        // Wrap to last enabled
        return GetLastEnabledIndex();
    }

    private int GetFirstEnabledIndex()
    {
        for (int i = 0; i < _triggers.Count; i++)
        {
            if (!_triggers[i].Disabled)
            {
                return i;
            }
        }
        return -1;
    }

    private int GetLastEnabledIndex()
    {
        for (int i = _triggers.Count - 1; i >= 0; i--)
        {
            if (!_triggers[i].Disabled)
            {
                return i;
            }
        }
        return -1;
    }

    private void HandleContextStateChanged()
    {
        // When context state changes (e.g., from AccordionTrigger),
        // update the controllable state
        var newOpenValues = _context.State.OpenValues;

        if (!_state.Value.SetEquals(newOpenValues))
        {
            _ = _state.SetValueAsync(new HashSet<string>(newOpenValues));

            // Invoke additional callback if provided
            if (OnValueChange.HasDelegate)
            {
                _ = OnValueChange.InvokeAsync(new HashSet<string>(newOpenValues));
            }

            StateHasChanged();
        }
    }

    public async ValueTask DisposeAsync()
    {
        if (_disposed)
        {
            return;
        }

        _disposed = true;
        _context.OnStateChanged -= HandleContextStateChanged;

        try
        {
            if (_keyboardNavCleanup is not null)
            {
                await _keyboardNavCleanup.InvokeVoidAsync("dispose");
                await _keyboardNavCleanup.DisposeAsync();
            }

            if (_keyboardNavModule is not null)
            {
                await _keyboardNavModule.DisposeAsync();
            }
        }
        catch (JSDisconnectedException)
        {
            // Circuit disconnected, ignore
        }
    }
}
