@typeparam TValue
@namespace BlazorBlueprint.Primitives.Select
@attribute [CascadingTypeParameter(nameof(TValue))]
@implements IDisposable
@inject BlazorBlueprint.Primitives.Services.DropdownManagerService? DropdownManager

@* Select root component - headless, unstyled behavior only *@
<CascadingValue Value="@_context" IsFixed="false">
    <div @attributes="AdditionalAttributes">
        @ChildContent
    </div>
</CascadingValue>

@code {
    private SelectContext<TValue> _context = new();
    private UseControllableState<TValue?> _state = null!;

    /// <summary>
    /// The child content to render within the select context.
    /// Typically includes SelectTrigger and SelectContent.
    /// </summary>
    [Parameter]
    public RenderFragment? ChildContent { get; set; }

    /// <summary>
    /// Additional attributes to apply to the root element.
    /// </summary>
    [Parameter(CaptureUnmatchedValues = true)]
    public Dictionary<string, object>? AdditionalAttributes { get; set; }

    /// <summary>
    /// The currently selected value (controlled mode).
    /// When null, the select manages its own state (uncontrolled mode).
    /// </summary>
    [Parameter]
    public TValue? Value { get; set; }

    /// <summary>
    /// Event callback invoked when the selected value changes.
    /// Use with @bind-Value for two-way binding.
    /// </summary>
    [Parameter]
    public EventCallback<TValue?> ValueChanged { get; set; }

    /// <summary>
    /// Default value when in uncontrolled mode.
    /// </summary>
    [Parameter]
    public TValue? DefaultValue { get; set; }

    /// <summary>
    /// Event callback invoked when the select value changes.
    /// Receives the new value as a parameter.
    /// </summary>
    [Parameter]
    public EventCallback<TValue?> OnValueChange { get; set; }

    /// <summary>
    /// Whether the select is disabled.
    /// </summary>
    [Parameter]
    public bool Disabled { get; set; }

    /// <summary>
    /// Controls whether the select dropdown is open (controlled mode).
    /// When null, the select manages its own open state (uncontrolled mode).
    /// </summary>
    [Parameter]
    public bool? Open { get; set; }

    /// <summary>
    /// Event callback invoked when the open state changes.
    /// Use with @bind-Open for two-way binding.
    /// </summary>
    [Parameter]
    public EventCallback<bool> OpenChanged { get; set; }

    /// <summary>
    /// Default open state when in uncontrolled mode.
    /// </summary>
    [Parameter]
    public bool DefaultOpen { get; set; } = false;

    /// <summary>
    /// Optional function to derive display text from the selected value.
    /// Use this when you have a pre-selected value and want to show its display text
    /// without waiting for the dropdown items to render and register.
    /// This keeps display text in sync automatically when the value changes.
    /// </summary>
    [Parameter]
    public Func<TValue, string>? DisplayTextSelector { get; set; }

    /// <summary>
    /// Default CSS classes to apply to all SelectItem children.
    /// Cascaded via the context so items can merge it with their own classes.
    /// </summary>
    [Parameter]
    public string? ItemClass { get; set; }

    protected override void OnInitialized()
    {
        // Initialize controllable state for value
        _state = new UseControllableState<TValue?>(DefaultValue)
        {
            ControlledValue = Value,
            OnValueChanged = ValueChanged,
            IsControlled = ValueChanged.HasDelegate
        };

        // Sync initial value to context
        _context.State.Value = _state.Value;
        _context.State.Disabled = Disabled;
        // Set initial DisplayText using DisplayTextSelector or Value.ToString().
        // Items will update this with correct display text once they register via ForceMount portal.
        _context.SetDisplayText(GetDisplayText(_state.Value));

        // Subscribe to context value changes
        _context.OnValueChange = async (newValue) =>
        {
            await _state.SetValueAsync(newValue);

            if (OnValueChange.HasDelegate)
            {
                await OnValueChange.InvokeAsync(newValue);
            }

            StateHasChanged();
        };

        // Subscribe to context state changes
        _context.OnStateChanged += HandleContextStateChanged;
    }

    protected override void OnParametersSet()
    {
        // Update disabled state
        if (_context.Disabled != Disabled)
        {
            _context.SetDisabled(Disabled);
        }

        // Update controlled value if it changed
        if (_state.IsControlled)
        {
            _state.ControlledValue = Value;
            _context.State.Value = Value;
            // Update DisplayText - registered items (always mounted via ForceMount) → DisplayTextSelector/ToString
            _context.SetDisplayText(_context.GetDisplayTextForValue(Value)
                ?? GetDisplayText(Value));
        }

        // Sync ItemClass to context
        _context.ItemClass = ItemClass;

        // Handle controlled open state
        if (Open.HasValue && _context.IsOpen != Open.Value)
        {
            if (Open.Value)
            {
                _context.Open();
            }
            else
            {
                _context.Close();
            }
        }
    }

    private void HandleContextStateChanged()
    {
        // Register/unregister with dropdown manager when open state changes
        if (DropdownManager != null)
        {
            if (_context.IsOpen)
            {
                // Register this dropdown as open; if another is open, it will be closed
                DropdownManager.RegisterOpen(_context.ContentId, () =>
                {
                    _context.Close();
                    InvokeAsync(StateHasChanged); // Ensure UI thread synchronization
                });
            }
            else
            {
                // Unregister when closed naturally
                DropdownManager.Unregister(_context.ContentId);
            }
        }

        // When context state changes (e.g., from SelectTrigger or click outside),
        // notify parent if Open is being controlled
        if (OpenChanged.HasDelegate)
        {
            var newOpenState = _context.IsOpen;
            if (!Open.HasValue || Open.Value != newOpenState)
            {
                _ = OpenChanged.InvokeAsync(newOpenState);
            }
        }

        StateHasChanged();
    }

    /// <summary>
    /// Gets the display text for a value using the DisplayTextSelector if available,
    /// otherwise falls back to Value.ToString().
    /// Returns null for default values of value types (e.g. 0 for int) when no
    /// DisplayTextSelector is provided, and gracefully handles selector exceptions.
    /// </summary>
    private string? GetDisplayText(TValue? value)
    {
        if (value == null)
        {
            return null;
        }

        if (DisplayTextSelector != null)
        {
            try
            {
                return DisplayTextSelector(value);
            }
            catch
            {
                // DisplayTextSelector may not handle default/unselected values —
                // fall back to null so the placeholder shows instead.
                return null;
            }
        }

        return value.ToString();
    }

    public void Dispose()
    {
        _context.OnStateChanged -= HandleContextStateChanged;

        // Unregister from dropdown manager on dispose
        if (DropdownManager != null && _context?.IsOpen == true)
        {
            DropdownManager.Unregister(_context.ContentId);
        }
    }
}
