@typeparam TValue
@namespace BlazorBlueprint.Primitives.Select
@using BlazorBlueprint.Primitives.Floating
@using BlazorBlueprint.Primitives.Services
@using Microsoft.JSInterop
@inject IJSRuntime JS
@implements IAsyncDisposable

@*
    SelectContent primitive - headless dropdown container.
    Uses FloatingPortal for portal/positioning infrastructure.
    Maintains Select-specific behavior: keyboard navigation, item focus, ARIA attributes.
*@

@if (_shouldRender && _context != null)
{
    <FloatingPortal IsOpen="@_context.IsOpen"
                    AnchorElement="@_context.State.TriggerElement"
                    PortalId="@_portalId"
                    Side="@Side"
                    Align="@Align"
                    Offset="@Offset"
                    MatchAnchorWidth="@MatchTriggerWidth"
                    Strategy="fixed"
                    ZIndex="9999"
                    OnReady="@HandleFloatingReady"
                    OnPlacementChanged="@HandlePlacementChanged">
        @RenderSelectListbox()
    </FloatingPortal>
}

@code {
    private bool _shouldRender => ForceMount || (_context?.IsOpen ?? false);
    private string _actualPlacement = "bottom";
    
    [CascadingParameter]
    private SelectContext<TValue>? _context { get; set; }

    private IJSObjectReference? _jsModule;
    private IJSObjectReference? _clickOutsideModule;
    private IJSObjectReference? _clickOutsideCleanup;
    private DotNetObjectReference<SelectContent<TValue>>? _dotNetRef;
    private bool _isKeyboardSetup = false;
    private string _portalId = "";

    /// <summary>
    /// Content to render inside the select dropdown.
    /// Typically contains SelectItem components.
    /// </summary>
    [Parameter]
    public RenderFragment? ChildContent { get; set; }

    /// <summary>
    /// Additional attributes to be applied to the content container.
    /// </summary>
    [Parameter(CaptureUnmatchedValues = true)]
    public Dictionary<string, object>? AdditionalAttributes { get; set; }

    /// <summary>
    /// Preferred side for positioning.
    /// Default is Bottom.
    /// </summary>
    [Parameter]
    public PopoverSide Side { get; set; } = PopoverSide.Bottom;

    /// <summary>
    /// Alignment relative to trigger.
    /// Default is Start.
    /// </summary>
    [Parameter]
    public PopoverAlign Align { get; set; } = PopoverAlign.Start;

    /// <summary>
    /// Offset distance from the trigger element in pixels.
    /// Default is 4.
    /// </summary>
    [Parameter]
    public int Offset { get; set; } = 4;

    /// <summary>
    /// Whether the select content should match the trigger width.
    /// Default is true (common pattern for selects).
    /// </summary>
    [Parameter]
    public bool MatchTriggerWidth { get; set; } = true;
    
    /// <summary>
    /// Whether to force mount the content even when the select is closed.
    /// When true, content remains mounted (useful for CSS animations).
    /// When false (default), content unmounts immediately (lower memory, no animation).
    /// </summary>
    [Parameter]
    public bool ForceMount { get; set; } = false;

    protected override void OnInitialized()
    {
        if (_context == null)
        {
            throw new InvalidOperationException(
                "SelectContent must be used within a Select component. " +
                "Ensure SelectContent is a child of a Select component.");
        }

        _portalId = $"select-portal-{_context.ContentId}";

        // Subscribe to context state changes for cleanup
        _context.OnStateChanged += HandleContextStateChanged;
    }

    protected override async Task OnAfterRenderAsync(bool firstRender)
    {
        if (firstRender && _jsModule == null)
        {
            _jsModule = await JS.InvokeAsync<IJSObjectReference>(
                "import", "./_content/BlazorBlueprint.Primitives/js/primitives/select.js");
        }
    }

    private RenderFragment RenderSelectListbox() => builder =>
    {
        // Re-cascade the SelectContext through the portal so SelectItem components can access it
        builder.OpenComponent<CascadingValue<SelectContext<TValue>>>(0);
        builder.AddAttribute(1, "Value", _context);
        builder.AddAttribute(2, "IsFixed", false);
        builder.AddAttribute(3, "ChildContent", (RenderFragment)(contentBuilder =>
        {
            contentBuilder.OpenElement(0, "div");
            contentBuilder.AddAttribute(1, "id", _context!.ContentId);
            contentBuilder.AddAttribute(2, "role", "listbox");
            contentBuilder.AddAttribute(3, "aria-labelledby", _context.TriggerId);
            contentBuilder.AddAttribute(4, "aria-activedescendant", GetActiveDescendantId());
            contentBuilder.AddAttribute(5, "data-select-content", "true");
            contentBuilder.AddAttribute(6, "tabindex", "-1");
            contentBuilder.AddAttribute(7, "data-state", _context.IsOpen ? "open" : "closed");
            contentBuilder.AddAttribute(8, "data-side", _actualPlacement);
            contentBuilder.AddMultipleAttributes(9, AdditionalAttributes);
            contentBuilder.AddContent(10, ChildContent);
            contentBuilder.CloseElement();
        }));
        builder.CloseComponent();
    };
    
    private void HandlePlacementChanged(string placement)
    {
        // Extract just the side part (e.g., "top" from "top-start")
        _actualPlacement = placement.Split('-')[0];
        StateHasChanged();
    }

    private async Task HandleFloatingReady()
    {
        if (_context == null || _jsModule == null) return;

        // CRITICAL: Scroll to selected item FIRST, before any awaits.
        // This ensures the scroll position is set before the rAF visibility callback
        // from FloatingPortal's ApplyPositionAsync can paint the visible content.
        var selectedValue = _context.State.Value?.ToString();
        await _jsModule.InvokeVoidAsync("focusInitialOption", _context.ContentId, selectedValue);

        // Focus the selected item or first item (updates Blazor state)
        _context.FocusSelectedOrFirst();

        // Set up click-outside detection
        await SetupClickOutsideAsync();

        // Set up JavaScript-based keyboard navigation
        if (!_isKeyboardSetup)
        {
            _dotNetRef = DotNetObjectReference.Create(this);
            await _jsModule.InvokeVoidAsync("setupKeyboardNavigation", _context.ContentId, _dotNetRef);
            _isKeyboardSetup = true;
        }
    }

    private async Task SetupClickOutsideAsync()
    {
        if (_context == null) return;

        try
        {
            _clickOutsideModule = await JS.InvokeAsync<IJSObjectReference>(
                "import", "./_content/BlazorBlueprint.Primitives/js/primitives/click-outside.js");

            if (_dotNetRef == null)
            {
                _dotNetRef = DotNetObjectReference.Create(this);
            }

            // Use ID-based lookup instead of ElementReference
            _clickOutsideCleanup = await _clickOutsideModule.InvokeAsync<IJSObjectReference>(
                "onClickOutsideByIds",
                _context.ContentId,      // Element ID (not ElementReference)
                _dotNetRef,
                "HandleClickOutside",
                _context.TriggerId);     // Trigger ID (not ElementReference)
        }
        catch (Exception ex)
        {
            Console.WriteLine($"Failed to set up click-outside: {ex.Message}");
        }
    }

    private async void HandleContextStateChanged()
    {
        // When context closes, clean up
        if (_context?.IsOpen == false && _isKeyboardSetup)
        {
            await InvokeAsync(async () =>
            {
                await CleanupSelectAsync();
                StateHasChanged();
            });
        }
    }

    private string? GetActiveDescendantId()
    {
        if (_context != null && _context.FocusedIndex >= 0)
        {
            return $"{_context.ContentId}-item-{_context.FocusedIndex}";
        }
        return null;
    }

    private async Task CleanupSelectAsync()
    {
        // Clean up keyboard navigation
        if (_jsModule != null && _context != null && _isKeyboardSetup)
        {
            try
            {
                await _jsModule.InvokeVoidAsync("cleanupKeyboardNavigation", _context.ContentId);
            }
            catch
            {
                // JS module may be disposed
            }
            _isKeyboardSetup = false;
        }

        // Clean up click-outside listener
        if (_clickOutsideCleanup != null)
        {
            try
            {
                await _clickOutsideCleanup.InvokeVoidAsync("dispose");
                await _clickOutsideCleanup.DisposeAsync();
            }
            catch
            {
                // Cleanup may already be disposed
            }
            _clickOutsideCleanup = null;
        }
    }

    /// <summary>
    /// Called from JavaScript when clicking outside the select.
    /// </summary>
    [JSInvokable]
    public void HandleClickOutside()
    {
        _context?.Close();
    }

    /// <summary>
    /// Called from JavaScript when the Escape key is pressed.
    /// </summary>
    [JSInvokable]
    public void HandleEscapeKey()
    {
        _context?.Close();
    }

    /// <summary>
    /// Called from JavaScript when the Tab key is pressed.
    /// </summary>
    [JSInvokable]
    public void HandleTabKey()
    {
        _context?.Close();
    }

    public async ValueTask DisposeAsync()
    {
        if (_context != null)
        {
            _context.OnStateChanged -= HandleContextStateChanged;
        }

        await CleanupSelectAsync();

        if (_clickOutsideModule != null)
        {
            await _clickOutsideModule.DisposeAsync();
        }

        if (_jsModule != null)
        {
            await _jsModule.DisposeAsync();
        }

        _dotNetRef?.Dispose();
    }
}
