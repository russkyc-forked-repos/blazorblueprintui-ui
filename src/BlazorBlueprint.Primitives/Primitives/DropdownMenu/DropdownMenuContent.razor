@namespace BlazorBlueprint.Primitives.DropdownMenu
@using BlazorBlueprint.Primitives.Floating
@using BlazorBlueprint.Primitives.Services
@inject IJSRuntime JSRuntime
@implements IAsyncDisposable

@*
    DropdownMenuContent is the main content container for the dropdown menu.
    Uses FloatingPortal for portal/positioning infrastructure.
    Maintains DropdownMenu-specific behavior: click-outside, keyboard navigation, focus management.
*@

@if (_shouldRender && Context.State.TriggerElement.HasValue)
{
    <FloatingPortal IsOpen="@Context.IsOpen"
                    AnchorElement="@Context.State.TriggerElement"
                    PortalId="@_portalId"
                    Side="@Side"
                    Align="@Align"
                    Offset="@Offset"
                    MatchAnchorWidth="@MatchTriggerWidth"
                    Strategy="@Strategy.ToValue()"
                    ZIndex="@ZIndex"
                    OnReady="@HandleFloatingReady"
                    OnPlacementChanged="@HandlePlacementChanged">
        @RenderDropdownContent()
    </FloatingPortal>
}

@code {
    private bool _shouldRender => ForceMount || Context.IsOpen;
    private string _actualPlacement = "bottom";
    
    [CascadingParameter]
    private DropdownMenuContext Context { get; set; } = null!;

    /// <summary>
    /// The content to render inside the dropdown menu.
    /// Typically contains DropdownMenuItem, DropdownMenuLabel, DropdownMenuSeparator, etc.
    /// </summary>
    [Parameter]
    public RenderFragment? ChildContent { get; set; }

    /// <summary>
    /// Additional attributes to apply to the content container.
    /// </summary>
    [Parameter(CaptureUnmatchedValues = true)]
    public Dictionary<string, object>? AdditionalAttributes { get; set; }

    /// <summary>
    /// Whether pressing Escape should close the dropdown menu.
    /// Default is true.
    /// </summary>
    [Parameter]
    public bool CloseOnEscape { get; set; } = true;

    /// <summary>
    /// Whether clicking outside should close the dropdown menu.
    /// Default is true.
    /// </summary>
    [Parameter]
    public bool CloseOnClickOutside { get; set; } = true;

    /// <summary>
    /// Preferred side for positioning.
    /// Default is Bottom.
    /// </summary>
    [Parameter]
    public PopoverSide Side { get; set; } = PopoverSide.Bottom;

    /// <summary>
    /// Alignment relative to trigger.
    /// Default is Start.
    /// </summary>
    [Parameter]
    public PopoverAlign Align { get; set; } = PopoverAlign.Start;

    /// <summary>
    /// Offset distance from the trigger element in pixels.
    /// Default is 4.
    /// </summary>
    [Parameter]
    public int Offset { get; set; } = 4;

    /// <summary>
    /// Event callback invoked when Escape key is pressed.
    /// </summary>
    [Parameter]
    public EventCallback<KeyboardEventArgs> OnEscapeKeyDown { get; set; }

    /// <summary>
    /// Event callback invoked when clicking outside the dropdown menu.
    /// </summary>
    [Parameter]
    public EventCallback OnClickOutside { get; set; }

    /// <summary>
    /// Whether to enable keyboard loop navigation (wrapping from last to first item).
    /// Default is true.
    /// </summary>
    [Parameter]
    public bool Loop { get; set; } = true;

    /// <summary>
    /// Z-index value for the dropdown menu.
    /// Default is 50.
    /// </summary>
    [Parameter]
    public int ZIndex { get; set; } = 50;

    /// <summary>
    /// Whether the dropdown content should match the trigger width.
    /// Default is false.
    /// </summary>
    [Parameter]
    public bool MatchTriggerWidth { get; set; } = false;

    /// <summary>
    /// Positioning strategy: "absolute" (default) or "fixed".
    /// Use "fixed" when dropdown needs to escape parent stacking contexts (e.g., in sidebars).
    /// Fixed strategy renders at document.body level.
    /// </summary>
    [Parameter]
    public PositioningStrategy Strategy { get; set; } = PositioningStrategy.Absolute;
    
    /// <summary>
    /// Whether to force mount the content even when the dropdown is closed.
    /// When true (default), content remains mounted enabling CSS exit animations.
    /// When false, content unmounts immediately (no animation, lower memory).
    /// </summary>
    [Parameter]
    public bool ForceMount { get; set; } = true;

    private ElementReference _contentRef;
    private IJSObjectReference? _clickOutsideModule;
    private IJSObjectReference? _clickOutsideCleanup;
    private IJSObjectReference? _keyboardNavModule;
    private IJSObjectReference? _keyboardNavCleanup;
    private IJSObjectReference? _matchWidthModule;
    private IJSObjectReference? _matchWidthCleanup;
    private DotNetObjectReference<DropdownMenuContent>? _dotNetRef;
    private bool _disposed = false;
    private string _portalId = "";

    // Track menu items for keyboard navigation
    private List<IDropdownMenuItem> _menuItems = new();

    protected override void OnInitialized()
    {
        if (Context == null)
        {
            throw new InvalidOperationException(
                "DropdownMenuContent must be used within a DropdownMenu component. " +
                "Ensure DropdownMenuContent is a child of a DropdownMenu component.");
        }

        _portalId = $"dropdown-portal-{Context.ContentId}";

        // Subscribe to context changes
        Context.OnStateChanged += HandleContextStateChanged;
    }

    private RenderFragment RenderDropdownContent() => __builder =>
    {
        <div @ref="_contentRef"
             id="@Context.ContentId"
             role="menu"
             tabindex="-1"
             data-autofocus
             @onkeydown="HandleKeyDown"
             @onkeydown:preventDefault="true"
             @attributes="GetAttributesWithoutStyle()"
             data-state="@(Context.IsOpen ? "open" : "closed")"
             data-side="@_actualPlacement">
            <CascadingValue Value="Context" IsFixed="false">
                <CascadingValue Value="this" Name="DropdownMenuContentContext" IsFixed="false">
                    @ChildContent
                </CascadingValue>
            </CascadingValue>
        </div>
    };
    
    private void HandlePlacementChanged(string placement)
    {
        // Extract just the side part (e.g., "top" from "top-start")
        _actualPlacement = string.IsNullOrEmpty(placement) ? "bottom" : placement.Split('-')[0];
        StateHasChanged();
    }

    private async Task HandleFloatingReady()
    {
        // Set up click-outside detection
        if (CloseOnClickOutside)
        {
            await SetupClickOutsideAsync();
        }

        // Set up keyboard navigation
        await SetupKeyboardNavAsync();

        // Set up width matching if needed
        if (MatchTriggerWidth)
        {
            await SetupMatchTriggerWidthAsync();
        }
    }

    private async Task SetupClickOutsideAsync()
    {
        try
        {
            _clickOutsideModule = await JSRuntime.InvokeAsync<IJSObjectReference>(
                "import", "./_content/BlazorBlueprint.Primitives/js/primitives/click-outside.js");

            _dotNetRef = DotNetObjectReference.Create(this);

            // Pass trigger element to exclude it from click-outside detection
            _clickOutsideCleanup = await _clickOutsideModule.InvokeAsync<IJSObjectReference>(
                "onClickOutside", _contentRef, _dotNetRef, "HandleClickOutside", Context.State.TriggerElement);
        }
        catch (Exception ex)
        {
            Console.WriteLine($"Failed to set up click-outside: {ex.Message}");
        }
    }

    private async Task SetupKeyboardNavAsync()
    {
        try
        {
            _keyboardNavModule = await JSRuntime.InvokeAsync<IJSObjectReference>(
                "import", "./_content/BlazorBlueprint.Primitives/js/primitives/keyboard-nav.js");

            _dotNetRef ??= DotNetObjectReference.Create(this);

            _keyboardNavCleanup = await _keyboardNavModule.InvokeAsync<IJSObjectReference>(
                "setupKeyboardNav", _contentRef, _dotNetRef);
        }
        catch (Exception ex)
        {
            Console.WriteLine($"Failed to set up keyboard navigation: {ex.Message}");
        }
    }

    private async Task SetupMatchTriggerWidthAsync()
    {
        try
        {
            _matchWidthModule = await JSRuntime.InvokeAsync<IJSObjectReference>(
                "import", "./_content/BlazorBlueprint.Primitives/js/primitives/match-trigger-width.js");

            _matchWidthCleanup = await _matchWidthModule.InvokeAsync<IJSObjectReference>(
                "matchTriggerWidth", Context.State.TriggerElement, _contentRef);
        }
        catch (Exception ex)
        {
            Console.WriteLine($"Failed to set up trigger width matching: {ex.Message}");
        }
    }

    [JSInvokable]
    public async Task HandleClickOutside()
    {
        // Guard against callbacks after disposal
        if (_disposed || !Context.IsOpen) return;

        // Invoke custom handler if provided
        if (OnClickOutside.HasDelegate)
        {
            await OnClickOutside.InvokeAsync();
        }

        // Close dropdown menu if configured
        if (CloseOnClickOutside)
        {
            Context.Close();
        }
    }

    private Dictionary<string, object>? GetAttributesWithoutStyle()
    {
        if (AdditionalAttributes == null) return null;

        // Create a copy without the style attribute
        var attributes = new Dictionary<string, object>(AdditionalAttributes);
        attributes.Remove("style");

        return attributes.Count > 0 ? attributes : null;
    }

    private async void HandleContextStateChanged()
    {
        if (!Context.IsOpen)
        {
            await InvokeAsync(async () =>
            {
                await CleanupAsync();
                StateHasChanged();
            });
        }
        else
        {
            await InvokeAsync(StateHasChanged);
        }
    }

    private async Task HandleKeyDown(KeyboardEventArgs args)
    {
        // Escape key
        if (args.Key == "Escape")
        {
            if (OnEscapeKeyDown.HasDelegate)
            {
                await OnEscapeKeyDown.InvokeAsync(args);
            }

            if (CloseOnEscape)
            {
                Context.Close();
            }
            return;
        }

        // Arrow navigation - use JS to navigate in DOM order
        if (_keyboardNavModule == null) return;

        try
        {
            switch (args.Key)
            {
                case "ArrowDown":
                    await _keyboardNavModule.InvokeVoidAsync("navigateNext", _contentRef, Loop);
                    break;

                case "ArrowUp":
                    await _keyboardNavModule.InvokeVoidAsync("navigatePrevious", _contentRef, Loop);
                    break;

                case "Home":
                    await _keyboardNavModule.InvokeVoidAsync("navigateFirst", _contentRef);
                    break;

                case "End":
                    await _keyboardNavModule.InvokeVoidAsync("navigateLast", _contentRef);
                    break;
            }
        }
        catch
        {
            // Ignore navigation errors
        }
    }

    private async Task CleanupAsync()
    {
        if (_clickOutsideCleanup != null)
        {
            try
            {
                await _clickOutsideCleanup.InvokeVoidAsync("dispose");
                await _clickOutsideCleanup.DisposeAsync();
            }
            catch
            {
                // Cleanup may already be disposed
            }
            _clickOutsideCleanup = null;
        }

        if (_keyboardNavCleanup != null)
        {
            try
            {
                await _keyboardNavCleanup.InvokeVoidAsync("dispose");
                await _keyboardNavCleanup.DisposeAsync();
            }
            catch
            {
                // Cleanup may already be disposed
            }
            _keyboardNavCleanup = null;
        }

        if (_matchWidthCleanup != null)
        {
            try
            {
                await _matchWidthCleanup.InvokeVoidAsync("dispose");
                await _matchWidthCleanup.DisposeAsync();
            }
            catch
            {
                // Cleanup may already be disposed
            }
            _matchWidthCleanup = null;
        }

        // Dispose DotNetObjectReference to prevent stale callbacks
        if (_dotNetRef != null)
        {
            _dotNetRef.Dispose();
            _dotNetRef = null;
        }
    }

    public async ValueTask DisposeAsync()
    {
        // Set disposed flag first to prevent JSInvokable callbacks during cleanup
        _disposed = true;

        await CleanupAsync();

        if (_clickOutsideModule != null)
        {
            await _clickOutsideModule.DisposeAsync();
        }

        if (_keyboardNavModule != null)
        {
            await _keyboardNavModule.DisposeAsync();
        }

        if (_matchWidthModule != null)
        {
            await _matchWidthModule.DisposeAsync();
        }

        _dotNetRef?.Dispose();

        if (Context != null)
        {
            Context.OnStateChanged -= HandleContextStateChanged;
        }
    }

    // Menu item registration for keyboard navigation (to be used in subtask 27.4)
    internal void RegisterMenuItem(IDropdownMenuItem item)
    {
        if (!_menuItems.Contains(item))
        {
            _menuItems.Add(item);
        }
    }

    internal void UnregisterMenuItem(IDropdownMenuItem item)
    {
        _menuItems.Remove(item);
    }

    internal List<IDropdownMenuItem> GetMenuItems() => _menuItems;
}
