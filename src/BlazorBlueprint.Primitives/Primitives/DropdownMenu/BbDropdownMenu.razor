@namespace BlazorBlueprint.Primitives.DropdownMenu
@implements IDisposable

@* DropdownMenu primitive root component - headless, unstyled behavior only *@
<CascadingValue Value="@_context" IsFixed="false">
    @ChildContent
</CascadingValue>

@code {
    private DropdownMenuContext _context = new();
    private UseControllableState<bool> _state = null!;

    /// <summary>
    /// The child content to render within the dropdown menu context.
    /// Typically includes DropdownMenuTrigger and DropdownMenuContent.
    /// </summary>
    [Parameter]
    public RenderFragment? ChildContent { get; set; }

    /// <summary>
    /// Controls whether the dropdown menu is open (controlled mode).
    /// When null, the dropdown menu manages its own state (uncontrolled mode).
    /// </summary>
    [Parameter]
    public bool? Open { get; set; }

    /// <summary>
    /// Event callback invoked when the open state changes.
    /// Use with @bind-Open for two-way binding.
    /// </summary>
    [Parameter]
    public EventCallback<bool> OpenChanged { get; set; }

    /// <summary>
    /// Default open state when in uncontrolled mode.
    /// </summary>
    [Parameter]
    public bool DefaultOpen { get; set; } = false;

    /// <summary>
    /// Event callback invoked when the dropdown menu open state changes.
    /// Receives the new open state as a parameter.
    /// </summary>
    [Parameter]
    public EventCallback<bool> OnOpenChange { get; set; }

    /// <summary>
    /// Whether the dropdown menu can be dismissed by clicking outside or pressing Escape.
    /// Default is true.
    /// </summary>
    [Parameter]
    public bool Modal { get; set; } = true;

    /// <summary>
    /// Direction for the menu content layout.
    /// Can be "ltr" (left-to-right) or "rtl" (right-to-left).
    /// Default is "ltr".
    /// </summary>
    [Parameter]
    public string Dir { get; set; } = "ltr";

    /// <summary>
    /// Default CSS classes to apply to all DropdownMenuItem children.
    /// Cascaded via the context so items can merge it with their own classes.
    /// </summary>
    [Parameter]
    public string? ItemClass { get; set; }

    protected override void OnInitialized()
    {
        // Initialize controllable state
        _state = new UseControllableState<bool>(DefaultOpen)
        {
            ControlledValue = Open ?? DefaultOpen,
            OnValueChanged = OpenChanged,
            IsControlled = Open.HasValue
        };

        // Sync initial state to context
        _context.State.IsOpen = _state.Value;

        // Subscribe to context state changes
        _context.OnStateChanged += HandleContextStateChanged;
    }

    protected override void OnParametersSet()
    {
        // Update controlled value if it changed
        if (_state.IsControlled && Open.HasValue)
        {
            _state.ControlledValue = Open.Value;
            _context.State.IsOpen = Open.Value;
        }

        // Sync ItemClass to context
        _context.ItemClass = ItemClass;
    }

    private void HandleContextStateChanged()
    {
        // When context state changes (e.g., from DropdownMenuTrigger or click outside),
        // update the controllable state
        var newOpenState = _context.State.IsOpen;

        if (_state.Value != newOpenState)
        {
            _ = _state.SetValueAsync(newOpenState);

            // Invoke additional callback if provided
            if (OnOpenChange.HasDelegate)
            {
                _ = OnOpenChange.InvokeAsync(newOpenState);
            }

            StateHasChanged();
        }
    }

    public void Dispose()
    {
        _context.OnStateChanged -= HandleContextStateChanged;
    }
}
