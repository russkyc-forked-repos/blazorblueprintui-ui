@namespace BlazorBlueprint.Primitives.DropdownMenu
@implements IDropdownMenuItem
@implements IDisposable

@* Dropdown menu item - represents an individual menu action *@
@if (HasHref)
{
    <a @ref="_itemRef"
       href="@(Disabled ? null : Href)"
       target="@Target"
       rel="@Rel"
       role="menuitem"
       tabindex="-1"
       aria-disabled="@Disabled.ToString().ToLower()"
       data-disabled="@(Disabled ? "true" : null)"
       @onclick="HandleClick"
       @onclick:preventDefault="@(Disabled)"
       @attributes="MergedAttributes">
        @ChildContent
    </a>
}
else
{
    <div @ref="_itemRef"
         role="menuitem"
         tabindex="-1"
         aria-disabled="@Disabled.ToString().ToLower()"
         data-disabled="@(Disabled ? "true" : null)"
         @onclick="HandleClick"
         @attributes="MergedAttributes">
        @ChildContent
    </div>
}

@code {
    [CascadingParameter]
    private DropdownMenuContext Context { get; set; } = null!;

    [CascadingParameter(Name = "DropdownMenuContentContext")]
    private BbDropdownMenuContent? ContentContext { get; set; }

    private ElementReference _itemRef;

    /// <summary>
    /// The content to display inside the menu item.
    /// </summary>
    [Parameter]
    public RenderFragment? ChildContent { get; set; }

    /// <summary>
    /// Additional attributes to apply to the menu item element.
    /// </summary>
    [Parameter(CaptureUnmatchedValues = true)]
    public Dictionary<string, object>? AdditionalAttributes { get; set; }

    /// <summary>
    /// URL to navigate to. When set, the item renders as an anchor element instead of a div.
    /// </summary>
    [Parameter]
    public string? Href { get; set; }

    /// <summary>
    /// The anchor target attribute (e.g., "_blank"). Only applies when Href is set.
    /// </summary>
    [Parameter]
    public string? Target { get; set; }

    private bool HasHref => !string.IsNullOrEmpty(Href);

    private string? Rel => Target == "_blank" ? "noopener noreferrer" : null;

    private Dictionary<string, object>? MergedAttributes
    {
        get
        {
            var itemClass = Context?.ItemClass;
            if (string.IsNullOrEmpty(itemClass))
            {
                return AdditionalAttributes;
            }

            var merged = AdditionalAttributes != null
                ? new Dictionary<string, object>(AdditionalAttributes)
                : new Dictionary<string, object>();

            if (merged.TryGetValue("class", out var existing))
            {
                merged["class"] = $"{itemClass} {existing}";
            }
            else
            {
                merged["class"] = itemClass;
            }

            return merged;
        }
    }

    /// <summary>
    /// Whether the menu item is disabled.
    /// </summary>
    [Parameter]
    public bool Disabled { get; set; } = false;

    /// <summary>
    /// Custom click handler. If provided, this is called when the item is clicked.
    /// The menu will close after the handler executes unless CloseOnSelect is false.
    /// </summary>
    [Parameter]
    public EventCallback<MouseEventArgs> OnClick { get; set; }

    /// <summary>
    /// Whether to close the dropdown menu when this item is selected.
    /// Default is true.
    /// </summary>
    [Parameter]
    public bool CloseOnSelect { get; set; } = true;

    protected override void OnInitialized()
    {
        if (Context == null)
        {
            throw new InvalidOperationException(
                "DropdownMenuItem must be used within a DropdownMenu component. " +
                "Ensure DropdownMenuItem is a child of a DropdownMenu component.");
        }
    }

    private async Task HandleClick(MouseEventArgs args)
    {
        if (Disabled) { return; }

        if (OnClick.HasDelegate)
        {
            await OnClick.InvokeAsync(args);
        }

        if (CloseOnSelect && Context != null)
        {
            Context.Close();
        }
    }

    // IDropdownMenuItem implementation
    public async Task FocusAsync()
    {
        try
        {
            await _itemRef.FocusAsync();
        }
        catch
        {
            // Ignore focus errors (element might not be mounted yet)
        }
    }

    public async Task ClickAsync()
    {
        if (Disabled) { return; }
        await HandleClick(new MouseEventArgs());
    }

    public void Dispose()
    {
    }
}
