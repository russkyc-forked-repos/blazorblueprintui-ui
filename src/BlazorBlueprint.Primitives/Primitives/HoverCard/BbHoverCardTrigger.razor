@namespace BlazorBlueprint.Primitives.HoverCard
@using System.Timers
@using BlazorBlueprint.Primitives.Utilities
@implements IDisposable

@* HoverCardTrigger primitive - trigger element that opens on hover *@
@if (AsChild)
{
    @* When AsChild is true, pass trigger context to child for it to handle *@
    <CascadingValue Value="TriggerContext" Name="TriggerContext">
        @ChildContent
    </CascadingValue>
}
else
{
    <div id="@Context.TriggerId"
         @ref="_triggerRef"
         @onmouseenter="HandleMouseEnter"
         @onmouseleave="HandleMouseLeave"
         @onfocus="HandleFocus"
         @onblur="HandleBlur"
         @attributes="AdditionalAttributes">
        @ChildContent
    </div>
}

@code {
    private ElementReference _triggerRef;
    private System.Timers.Timer? _openTimer;
    private System.Timers.Timer? _closeTimer;

    /// <summary>
    /// Cascading parameter to receive the hover card context.
    /// </summary>
    [CascadingParameter]
    public HoverCardContext Context { get; set; } = null!;

    /// <summary>
    /// The child content to render within the trigger.
    /// </summary>
    [Parameter]
    public RenderFragment? ChildContent { get; set; }

    /// <summary>
    /// When true, the trigger does not render its own div element.
    /// Instead, it passes trigger behavior via TriggerContext to child components.
    /// The child component must consume TriggerContext and apply hover/focus behavior.
    /// </summary>
    [Parameter]
    public bool AsChild { get; set; } = false;

    /// <summary>
    /// Additional attributes to apply to the trigger element.
    /// </summary>
    [Parameter(CaptureUnmatchedValues = true)]
    public Dictionary<string, object>? AdditionalAttributes { get; set; }

    /// <summary>
    /// Stores the trigger element reference when using AsChild pattern.
    /// </summary>
    private ElementReference? _asChildTriggerRef;

    /// <summary>
    /// Context passed to child components when AsChild is true.
    /// </summary>
    private TriggerContext TriggerContext => new()
    {
        TriggerId = Context.TriggerId,
        IsOpen = Context.IsOpen,
        Open = () => Context.Open(_asChildTriggerRef),
        Close = () => Context.Close(),
        OnMouseEnter = HandleMouseEnterForContext,
        OnMouseLeave = HandleMouseLeaveForContext,
        OnFocus = HandleFocusForContext,
        OnBlur = HandleBlurForContext,
        SetTriggerElement = (ElementReference el) => _asChildTriggerRef = el
    };

    private void HandleMouseEnterForContext()
    {
        CancelCloseTimer();
        if (!Context.IsOpen)
        {
            _openTimer?.Dispose();
            _openTimer = new System.Timers.Timer(Context.OpenDelay);
            _openTimer.Elapsed += OnOpenTimerElapsedForContext;
            _openTimer.AutoReset = false;
            _openTimer.Start();
        }
    }

    private void HandleMouseLeaveForContext()
    {
        CancelOpenTimer();
        if (Context.IsOpen)
        {
            _closeTimer?.Dispose();
            _closeTimer = new System.Timers.Timer(Context.CloseDelay);
            _closeTimer.Elapsed += OnCloseTimerElapsed;
            _closeTimer.AutoReset = false;
            _closeTimer.Start();
        }
    }

    private void HandleFocusForContext()
    {
        CancelCloseTimer();
        if (!Context.IsOpen)
        {
            Context.Open(_asChildTriggerRef);
            InvokeAsync(StateHasChanged);
        }
    }

    private void HandleBlurForContext()
    {
        CancelOpenTimer();
        if (Context.IsOpen)
        {
            _closeTimer?.Dispose();
            _closeTimer = new System.Timers.Timer(Context.CloseDelay);
            _closeTimer.Elapsed += OnCloseTimerElapsed;
            _closeTimer.AutoReset = false;
            _closeTimer.Start();
        }
    }

    protected override void OnInitialized()
    {
        if (Context == null)
        {
            throw new InvalidOperationException("HoverCardTrigger must be used within a HoverCard component.");
        }
    }

    protected override void OnAfterRender(bool firstRender)
    {
        // Proactively set the trigger element reference so it's available
        // even when the hover card is opened programmatically (via @bind-Open)
        if (!AsChild)
        {
            Context.SetTriggerElement(_triggerRef);
        }
        else if (_asChildTriggerRef.HasValue)
        {
            // When using AsChild pattern, the child component (e.g., Button) sets
            // _asChildTriggerRef via TriggerContext.SetTriggerElement. We need to
            // propagate this to the context so Content can position relative to it.
            Context.SetTriggerElement(_asChildTriggerRef.Value);
        }
    }

    private void HandleMouseEnter()
    {
        CancelCloseTimer();

        if (!Context.IsOpen)
        {
            _openTimer?.Dispose();
            _openTimer = new System.Timers.Timer(Context.OpenDelay);
            _openTimer.Elapsed += OnOpenTimerElapsed;
            _openTimer.AutoReset = false;
            _openTimer.Start();
        }
    }

    private void HandleMouseLeave()
    {
        CancelOpenTimer();

        if (Context.IsOpen)
        {
            _closeTimer?.Dispose();
            _closeTimer = new System.Timers.Timer(Context.CloseDelay);
            _closeTimer.Elapsed += OnCloseTimerElapsed;
            _closeTimer.AutoReset = false;
            _closeTimer.Start();
        }
    }

    private void HandleFocus()
    {
        CancelCloseTimer();

        if (!Context.IsOpen)
        {
            // Open immediately on focus (keyboard navigation)
            Context.Open(_triggerRef);
            InvokeAsync(StateHasChanged);
        }
    }

    private void HandleBlur()
    {
        CancelOpenTimer();

        if (Context.IsOpen)
        {
            // Close with delay on blur
            _closeTimer?.Dispose();
            _closeTimer = new System.Timers.Timer(Context.CloseDelay);
            _closeTimer.Elapsed += OnCloseTimerElapsed;
            _closeTimer.AutoReset = false;
            _closeTimer.Start();
        }
    }

    private void OnOpenTimerElapsed(object? sender, ElapsedEventArgs e)
    {
        InvokeAsync(() =>
        {
            Context.Open(_triggerRef);
            StateHasChanged();
        });
    }

    private void OnOpenTimerElapsedForContext(object? sender, ElapsedEventArgs e)
    {
        InvokeAsync(() =>
        {
            Context.Open(_asChildTriggerRef);
            StateHasChanged();
        });
    }

    private void OnCloseTimerElapsed(object? sender, ElapsedEventArgs e)
    {
        InvokeAsync(() =>
        {
            Context.Close();
            StateHasChanged();
        });
    }

    private void CancelOpenTimer()
    {
        if (_openTimer != null)
        {
            _openTimer.Stop();
            _openTimer.Dispose();
            _openTimer = null;
        }
    }

    private void CancelCloseTimer()
    {
        if (_closeTimer != null)
        {
            _closeTimer.Stop();
            _closeTimer.Dispose();
            _closeTimer = null;
        }
    }

    public void Dispose()
    {
        CancelOpenTimer();
        CancelCloseTimer();
    }
}
