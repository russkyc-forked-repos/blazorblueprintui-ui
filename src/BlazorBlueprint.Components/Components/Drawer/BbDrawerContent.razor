@namespace BlazorBlueprint.Components
@using Microsoft.JSInterop
@inject BlazorBlueprint.Primitives.Services.IFocusManager FocusManager
@inject IJSRuntime JS
@implements IAsyncDisposable

@if (Context?.IsOpen == true)
{
    @* Overlay *@
    <div class="fixed inset-0 z-50 bg-black/80 data-[state=open]:animate-in data-[state=closed]:animate-out data-[state=closed]:fade-out-0 data-[state=open]:fade-in-0"
         data-state="open"
         @onclick="HandleOverlayClick">
    </div>

    @* Drawer Content *@
    <div @ref="_contentRef"
         class="@CssClass"
         data-state="open"
         role="dialog"
         aria-modal="true"
         tabindex="-1"
         >
        @if (ShowHandle)
        {
            <div class="mx-auto mt-4 h-2 w-[100px] rounded-full bg-muted"></div>
        }
        @ChildContent
    </div>
}

@code {
    [CascadingParameter]
    public BbDrawer? Context { get; set; }

    [Parameter]
    public string? Class { get; set; }

    [Parameter]
    public RenderFragment? ChildContent { get; set; }

    [Parameter]
    public bool ShowHandle { get; set; } = true;

    [Parameter]
    public bool TrapFocus { get; set; } = true;

    [Parameter]
    public bool LockScroll { get; set; } = true;

    [Parameter]
    public bool CloseOnEscape { get; set; } = true;

    private ElementReference _contentRef;
    private IAsyncDisposable? _focusTrap;
    private IJSObjectReference? _portalModule;
    private IJSObjectReference? _scrollLockCleanup;
    private IJSObjectReference? _escapeModule;
    private DotNetObjectReference<BbDrawerContent>? _dotNetRef;
    private string _instanceId = Guid.NewGuid().ToString("N");
    private bool _isInitialized;
    private bool _disposed;

    protected override async Task OnAfterRenderAsync(bool firstRender)
    {
        if (Context?.IsOpen == true && !_isInitialized)
        {
            _isInitialized = true;

            // Set up focus trap
            if (TrapFocus)
            {
                try
                {
                    _focusTrap = await FocusManager.TrapFocus(_contentRef);
                }
                catch (JSDisconnectedException)
                {
                    // Expected during circuit disconnect in Blazor Server
                }
                catch (InvalidOperationException)
                {
                    // JS interop not available during prerendering
                }
            }

            // Lock body scroll
            if (LockScroll)
            {
                try
                {
                    _portalModule = await JS.InvokeAsync<IJSObjectReference>(
                        "import", "./_content/BlazorBlueprint.Primitives/js/primitives/portal.js");
                    _scrollLockCleanup = await _portalModule.InvokeAsync<IJSObjectReference>("lockBodyScroll");
                }
                catch (JSDisconnectedException)
                {
                    // Expected during circuit disconnect in Blazor Server
                }
                catch (InvalidOperationException)
                {
                    // JS interop not available during prerendering
                }
            }

            // Set up escape key detection in JS (avoids C# round-trip on every keystroke)
            try
            {
                _escapeModule = await JS.InvokeAsync<IJSObjectReference>(
                    "import", "./_content/BlazorBlueprint.Primitives/js/primitives/escape-keydown.js");
                _dotNetRef = DotNetObjectReference.Create(this);
                await _escapeModule.InvokeVoidAsync("initialize", _dotNetRef, _instanceId);
            }
            catch (JSDisconnectedException)
            {
                // Expected during circuit disconnect in Blazor Server
            }
            catch (InvalidOperationException)
            {
                // JS interop not available during prerendering
            }
        }
        else if (Context?.IsOpen != true && _isInitialized)
        {
            await CleanupAsync();
        }
    }

    private async Task HandleOverlayClick()
    {
        if (Context != null)
        {
            await Context.SetOpen(false);
        }
    }

    [JSInvokable]
    public async Task JsOnEscapeKey()
    {
        if (_disposed || Context == null) { return; }

        if (CloseOnEscape)
        {
            await Context.SetOpen(false);
        }
    }

    private async Task CleanupAsync()
    {
        // Dispose focus trap
        if (_focusTrap != null)
        {
            try
            {
                await _focusTrap.DisposeAsync();
            }
            catch
            {
                // Ignore disposal errors
            }
            _focusTrap = null;
        }

        // Unlock body scroll
        if (_scrollLockCleanup != null)
        {
            try
            {
                await _scrollLockCleanup.InvokeVoidAsync("apply");
            }
            catch
            {
                // Cleanup may already be disposed
            }
            _scrollLockCleanup = null;
        }

        // Remove escape key listener
        if (_escapeModule != null)
        {
            try
            {
                await _escapeModule.InvokeVoidAsync("dispose", _instanceId);
            }
            catch
            {
                // Cleanup may already be disposed
            }
        }

        _dotNetRef?.Dispose();
        _dotNetRef = null;

        _isInitialized = false;
    }

    public async ValueTask DisposeAsync()
    {
        _disposed = true;
        GC.SuppressFinalize(this);

        await CleanupAsync();

        if (_portalModule != null)
        {
            try
            {
                await _portalModule.DisposeAsync();
            }
            catch (JSDisconnectedException)
            {
                // Expected during circuit disconnect
            }
        }

        if (_escapeModule != null)
        {
            try
            {
                await _escapeModule.DisposeAsync();
            }
            catch (JSDisconnectedException)
            {
                // Expected during circuit disconnect
            }
        }

        _dotNetRef?.Dispose();
    }

    private string DirectionClasses => Context?.Direction switch
    {
        DrawerDirection.Top => "inset-x-0 top-0 border-b data-[state=open]:slide-in-from-top data-[state=closed]:slide-out-to-top",
        DrawerDirection.Bottom => "inset-x-0 bottom-0 border-t data-[state=open]:slide-in-from-bottom data-[state=closed]:slide-out-to-bottom",
        DrawerDirection.Left => "inset-y-0 left-0 h-full w-3/4 border-r data-[state=open]:slide-in-from-left data-[state=closed]:slide-out-to-left sm:max-w-sm",
        DrawerDirection.Right => "inset-y-0 right-0 h-full w-3/4 border-l data-[state=open]:slide-in-from-right data-[state=closed]:slide-out-to-right sm:max-w-sm",
        _ => "inset-x-0 bottom-0 border-t data-[state=open]:slide-in-from-bottom data-[state=closed]:slide-out-to-bottom"
    };

    private string CssClass => ClassNames.cn(
        "fixed z-50 gap-4 bg-background p-6 shadow-lg transition ease-in-out",
        "data-[state=open]:animate-in data-[state=closed]:animate-out data-[state=closed]:duration-300 data-[state=open]:duration-500",
        DirectionClasses,
        Class
    );
}
