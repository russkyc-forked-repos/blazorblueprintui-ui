@namespace BlazorBlueprint.Components
@using Microsoft.AspNetCore.Components.Forms
@using System.Linq.Expressions
@inject IJSRuntime JSRuntime

<div id="@EffectiveId" class="@ContainerClass" @onpaste="HandlePaste">
    @if (EffectiveName != null)
    {
        <input type="hidden" name="@EffectiveName" value="@Value" />
    }
    @for (int i = 0; i < Length; i++)
    {
        var index = i;
        <input @ref="_inputRefs[index]"
               type="text"
               inputmode="numeric"
               maxlength="1"
               class="@ComputedInputClass"
               value="@GetValueAt(index)"
               disabled="@Disabled"
               @oninput="@(e => HandleInput(index, e))"
               @onkeydown="@(e => HandleKeyDown(index, e))"
               @onfocus="@(() => HandleFocus(index))" />
        @if (ShowSeparator && index < Length - 1 && (index + 1) % GroupSize == 0)
        {
            <div class="@SeparatorClass">
                @if (Separator != null)
                {
                    @Separator
                }
                else
                {
                    <span>-</span>
                }
            </div>
        }
    }
</div>

@code {
    private FieldIdentifier _fieldIdentifier;
    private EditContext? _editContext;

    [CascadingParameter]
    private EditContext? CascadedEditContext { get; set; }

    /// <summary>
    /// The number of OTP digits.
    /// </summary>
    [Parameter]
    public int Length { get; set; } = 6;

    /// <summary>
    /// The current OTP value.
    /// </summary>
    [Parameter]
    public string? Value { get; set; }

    /// <summary>
    /// Event callback when the value changes.
    /// </summary>
    [Parameter]
    public EventCallback<string> ValueChanged { get; set; }

    /// <summary>
    /// Gets or sets the HTML name attribute for the input elements.
    /// </summary>
    /// <remarks>
    /// When inside an EditForm and not explicitly set, the name is automatically
    /// derived from the ValueExpression (FieldIdentifier) to support SSR form postback.
    /// Individual digit inputs will use the name with an index suffix.
    /// </remarks>
    [Parameter]
    public string? Name { get; set; }

    /// <summary>
    /// Gets or sets an expression that identifies the bound value.
    /// </summary>
    [Parameter]
    public Expression<Func<string?>>? ValueExpression { get; set; }

    /// <summary>
    /// Event callback when all digits are filled.
    /// </summary>
    [Parameter]
    public EventCallback<string> OnComplete { get; set; }

    /// <summary>
    /// Whether the input is disabled.
    /// </summary>
    [Parameter]
    public bool Disabled { get; set; }

    /// <summary>
    /// Whether to show separators between groups.
    /// </summary>
    [Parameter]
    public bool ShowSeparator { get; set; } = true;

    /// <summary>
    /// Number of digits per group (for separator placement).
    /// </summary>
    [Parameter]
    public int GroupSize { get; set; } = 3;

    /// <summary>
    /// Custom separator content.
    /// </summary>
    [Parameter]
    public RenderFragment? Separator { get; set; }

    /// <summary>
    /// Additional CSS classes for the container.
    /// </summary>
    [Parameter]
    public string? Class { get; set; }

    /// <summary>
    /// Additional CSS classes to apply to each individual OTP input box.
    /// </summary>
    [Parameter]
    public string? InputClass { get; set; }

    /// <summary>
    /// Size variant for the input boxes.
    /// </summary>
    [Parameter]
    public InputOTPSize Size { get; set; } = InputOTPSize.Default;

    /// <summary>
    /// Gets or sets the HTML id attribute for the OTP container element.
    /// Auto-generated if not specified.
    /// </summary>
    [Parameter]
    public string? Id { get; set; }

    private ElementReference[] _inputRefs = Array.Empty<ElementReference>();
    private string[] _values = Array.Empty<string>();
    private string? _generatedId;

    protected override void OnInitialized()
    {
        _inputRefs = new ElementReference[Length];
        _values = new string[Length];

        if (!string.IsNullOrEmpty(Value))
        {
            for (int i = 0; i < Math.Min(Value.Length, Length); i++)
            {
                _values[i] = Value[i].ToString();
            }
        }
    }

    protected override void OnParametersSet()
    {
        if (_values.Length != Length)
        {
            _inputRefs = new ElementReference[Length];
            _values = new string[Length];
        }

        if (!string.IsNullOrEmpty(Value))
        {
            for (int i = 0; i < Length; i++)
            {
                _values[i] = i < Value.Length ? Value[i].ToString() : "";
            }
        }

        if (CascadedEditContext != null && ValueExpression != null)
        {
            _editContext = CascadedEditContext;
            _fieldIdentifier = FieldIdentifier.Create(ValueExpression);
        }
    }

    private string GetValueAt(int index)
    {
        return index < _values.Length ? _values[index] ?? "" : "";
    }

    private async Task HandleInput(int index, ChangeEventArgs e)
    {
        var inputValue = e.Value?.ToString() ?? "";

        // Only accept digits
        if (!string.IsNullOrEmpty(inputValue) && !char.IsDigit(inputValue[0]))
        {
            return;
        }

        _values[index] = inputValue.Length > 0 ? inputValue[0].ToString() : "";

        var newValue = string.Join("", _values);
        await ValueChanged.InvokeAsync(newValue);

        if (_editContext != null && ValueExpression != null && _fieldIdentifier.FieldName != null)
        {
            _editContext.NotifyFieldChanged(_fieldIdentifier);
        }

        // Move to next input if value entered
        if (!string.IsNullOrEmpty(_values[index]) && index < Length - 1)
        {
            await FocusInput(index + 1);
        }

        // Check if complete
        if (newValue.Length == Length && !newValue.Contains(""))
        {
            var completeValue = string.Join("", _values.Where(v => !string.IsNullOrEmpty(v)));
            if (completeValue.Length == Length)
            {
                await OnComplete.InvokeAsync(completeValue);
            }
        }
    }

    private async Task HandleKeyDown(int index, KeyboardEventArgs e)
    {
        if (e.Key == "Backspace" && string.IsNullOrEmpty(_values[index]) && index > 0)
        {
            // Move to previous input on backspace when current is empty
            await FocusInput(index - 1);
        }
        else if (e.Key == "ArrowLeft" && index > 0)
        {
            await FocusInput(index - 1);
        }
        else if (e.Key == "ArrowRight" && index < Length - 1)
        {
            await FocusInput(index + 1);
        }
    }

    private void HandlePaste(ClipboardEventArgs e)
    {
        // Handle paste - filled in via JS interop if needed
    }

    private void HandleFocus(int index)
    {
        // Select content on focus
    }

    private async Task FocusInput(int index)
    {
        if (index >= 0 && index < _inputRefs.Length)
        {
            try
            {
                await _inputRefs[index].FocusAsync();
            }
            catch
            {
                // Ignore focus errors
            }
        }
    }

    /// <summary>
    /// Gets the effective name attribute, falling back to the FieldIdentifier name when inside an EditForm.
    /// </summary>
    private string? EffectiveName => Name ?? (_editContext != null && _fieldIdentifier.FieldName != null ? _fieldIdentifier.FieldName : null);

    private string EffectiveId => Id ?? (_generatedId ??= $"otp-{Guid.NewGuid().ToString("N")[..8]}");

    private string SizeClasses => Size switch
    {
        InputOTPSize.Small => "h-8 w-8 text-sm",
        InputOTPSize.Default => "h-10 w-10 text-base",
        InputOTPSize.Large => "h-12 w-12 text-lg",
        _ => "h-10 w-10 text-base"
    };

    private string ContainerClass => ClassNames.cn(
        "flex items-center gap-2",
        Class
    );

    private string ComputedInputClass => ClassNames.cn(
        "flex items-center justify-center rounded-md border border-input bg-background text-center font-medium",
        "focus:outline-none",
        "disabled:cursor-not-allowed disabled:opacity-50",
        SizeClasses,
        InputClass
    );

    private string SeparatorClass => "flex items-center justify-center text-muted-foreground";
}
